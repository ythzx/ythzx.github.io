<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>rabbitmq消息队列 | Peter&#39;s Blog Center</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="Django" />
  
  
  
  
  <meta name="description" content="rabbitmq消息队列centos下yum安装RabbitMQ">
<meta property="og:type" content="article">
<meta property="og:title" content="rabbitmq消息队列">
<meta property="og:url" content="https://github.com/ythzx/ythzx.github.io/2017/08/08/rabbitmq消息队列/index.html">
<meta property="og:site_name" content="Peter's Blog Center">
<meta property="og:description" content="rabbitmq消息队列centos下yum安装RabbitMQ">
<meta property="og:image" content="http://images2017.cnblogs.com/blog/658994/201708/658994-20170808184951199-2113197381.png">
<meta property="og:image" content="http://www.rabbitmq.com/img/tutorials/python-two.png?_=5248247">
<meta property="og:image" content="http://images2017.cnblogs.com/blog/658994/201708/658994-20170808232825808-1635320985.jpg">
<meta property="og:image" content="http://images2017.cnblogs.com/blog/658994/201708/658994-20170809002827902-992989750.jpg">
<meta property="og:image" content="http://images2017.cnblogs.com/blog/658994/201708/658994-20170809201519136-1750807597.jpg">
<meta property="og:image" content="http://images2017.cnblogs.com/blog/658994/201708/658994-20170809202558761-1869604347.jpg">
<meta property="og:image" content="http://www.rabbitmq.com/img/tutorials/python-six.png?_=5248247">
<meta property="og:updated_time" content="2017-08-09T15:56:07.881Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="rabbitmq消息队列">
<meta name="twitter:description" content="rabbitmq消息队列centos下yum安装RabbitMQ">
<meta name="twitter:image" content="http://images2017.cnblogs.com/blog/658994/201708/658994-20170808184951199-2113197381.png">
  
    <link rel="alternate" href="/atom.xml" title="Peter&#39;s Blog Center" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/hiero.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="Peter&#39;s Blog Center" rel="home"> Peter&#39;s Blog Center </a>
            
          </h1>

          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>




  <div id="container" style='background: rgba(255,255,255,0.5);'>
    <div id="wrap" style='background: rgba(255,255,255,0.5);'>
            
      <div id="content" class="outer" style='background: rgba(255,255,255,0.5);'>
        
          <section id="main" style="float:none;"><article id="post-rabbitmq消息队列" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      rabbitmq消息队列
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/2017/08/08/rabbitmq消息队列/" class="article-date">
	  <time datetime="2017-08-08T00:42:22.447Z" itemprop="datePublished">八月 8, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="rabbitmq消息队列"><a href="#rabbitmq消息队列" class="headerlink" title="rabbitmq消息队列"></a>rabbitmq消息队列</h1><h2 id="centos下yum安装RabbitMQ"><a href="#centos下yum安装RabbitMQ" class="headerlink" title="centos下yum安装RabbitMQ"></a>centos下yum安装RabbitMQ</h2><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">1.安装前准备 </div><div class="line">    wget http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</div><div class="line">    rpm -ivh epel-release-6-8.noarch.rpm</div><div class="line">    wget -P /etc/yum.repos.d/ http://repos.fedorapeople.org/repos/peter/erlang/epel-erlang.repo </div><div class="line">    yum clean all </div><div class="line">    yum -y install erlang</div><div class="line"></div><div class="line"></div><div class="line">2.安装rabbitmq </div><div class="line">    rpm --import http://www.rabbitmq.com/rabbitmq-signing-key-public.asc </div><div class="line">    wget http://www.rabbitmq.com/releases/rabbitmq-server/v2.8.5/rabbitmq-server-2.8.5-1.noarch.rpm </div><div class="line">    rpm -ivh rabbitmq-server-2.8.5-1.noarch.rpm</div><div class="line"></div><div class="line"></div><div class="line">3.启动rabbitmq并设置开机启动 </div><div class="line">    chkconfig rabbitmq-server on </div><div class="line">    /sbin/service rabbitmq-server start</div><div class="line">    或者systemctl start rabbitmq-server start</div><div class="line"></div><div class="line"></div><div class="line">4.检查rabbitmq是否启动 </div><div class="line">    ps aux|grep rabbitmq</div><div class="line">    或者</div><div class="line">    systemctl status rabbitmq-server</div></pre></td></tr></table></figure>
<h3 id="python的队列-queue"><a href="#python的队列-queue" class="headerlink" title="python的队列 queue"></a>python的队列 queue</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">q=queue.Queue()</div><div class="line">q.put()</div><div class="line">q.qsize()</div><div class="line">q.get()</div></pre></td></tr></table></figure>
<p><strong>先进先出</strong></p>
<h3 id="消息队列解决的问题："><a href="#消息队列解决的问题：" class="headerlink" title="消息队列解决的问题："></a>消息队列解决的问题：</h3><ul>
<li>解耦 天然的解耦</li>
<li>异步<br>  优点：解决排队问题<br>  缺点：不能保证任务及时执行<br>  应用场景：飞机购票<br>同步：<br>  优点：保证任务及时执行<br>  缺点：排队问题</li>
</ul>
<p>大并发<br>    Web nginx 10000-20000<br>    pv = page visit<br>        一亿的pv用10台server 集群<br>        pv分散到实际的用户上并不多</p>
<pre><code>uv = user visit
</code></pre><h3 id="队列的作用："><a href="#队列的作用：" class="headerlink" title="队列的作用："></a>队列的作用：</h3><ul>
<li>存储消息、数据</li>
<li>保证消息的顺序</li>
<li>保证数据的交付</li>
</ul>
<h3 id="引入rabbitmq的原因："><a href="#引入rabbitmq的原因：" class="headerlink" title="引入rabbitmq的原因："></a>引入rabbitmq的原因：</h3><p>python只能在同一进程中起作用，不能跨进程</p>
<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p>解决了耦合性，生产者和消费者之间没有直接的联系</p>
<p>其中最重要的就是队列</p>
<h2 id="RabbitMQ-配置"><a href="#RabbitMQ-配置" class="headerlink" title="RabbitMQ 配置"></a>RabbitMQ 配置</h2><p>在python中安装pika,<code>pip install pika</code>,通过pika连接rabbitmq</p>
<p>远程连接rabbitmq server的话，需要配置权限</p>
<h3 id="rabbitmq-创建用户和设置权限"><a href="#rabbitmq-创建用户和设置权限" class="headerlink" title="rabbitmq 创建用户和设置权限"></a>rabbitmq 创建用户和设置权限</h3><ul>
<li>首先在rabbitmq server上创建一个用户<br>  rabbitmqctl  add_user aaa 密码</li>
<li>同时还要配置权限，允许从外面访问<br>  rabbitmqctl set_permissions -p / aaa “.<em>“ “.</em>“ “.*”</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">set_permissions [-p vhost] &#123;user&#125; &#123;conf&#125; &#123;write&#125; &#123;read&#125;</div><div class="line"></div><div class="line">vhost</div><div class="line">The name of the virtual host to which to grant the user access, defaulting to /. ，默认是 /</div><div class="line"></div><div class="line">user</div><div class="line">The name of the user to grant access to the specified virtual host.</div><div class="line"></div><div class="line">conf</div><div class="line">A regular expression matching resource names for which the user is granted configure permissions.</div><div class="line"></div><div class="line">write</div><div class="line">A regular expression matching resource names for which the user is granted write permissions.</div><div class="line"></div><div class="line">read</div><div class="line">A regular expression matching resource names for which the user is granted read permissions.</div></pre></td></tr></table></figure>
<h3 id="客户端连接的时候需要配置认证参数"><a href="#客户端连接的时候需要配置认证参数" class="headerlink" title="客户端连接的时候需要配置认证参数"></a>客户端连接的时候需要配置认证参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">credentials = pika.PlainCredentials(<span class="string">'aaa'</span>, <span class="string">'密码'</span>)</div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'10.211.55.5'</span>,<span class="number">5672</span>,<span class="string">'/'</span>,credentials))</div><div class="line">channel = connection.channel()</div></pre></td></tr></table></figure>
<h2 id="RabbitMQ-都能为程序提供队列"><a href="#RabbitMQ-都能为程序提供队列" class="headerlink" title="RabbitMQ 都能为程序提供队列"></a>RabbitMQ 都能为程序提供队列</h2><p>Exchange 负责消息过滤</p>
<p>RabbitMQ的默认端口是5672</p>
<p><code>rabbitmpctl list_queues</code> 显示当前的队列列表</p>
<p>生产者：<br>    端口 ip 认证信息<br>    创建队列<br>    向队列发送消息<br>消费者<br>    端口 ip 认证信息<br>    从指定的队列中取消息</p>
<h3 id="1-rabbitmq的路由routing-key"><a href="#1-rabbitmq的路由routing-key" class="headerlink" title="1 rabbitmq的路由routing_key"></a>1 rabbitmq的路由routing_key</h3><p>发送消息：<br>routing_key = ‘hello’ 把消息队列转到和hello</p>
<p>获取消息：<br>callback</p>
<p>channel.start_consuming() # 阻塞模式</p>
<h3 id="2-实现最简单的队列"><a href="#2-实现最简单的队列" class="headerlink" title="2 实现最简单的队列"></a>2 实现最简单的队列</h3><p>生产者：</p>
<ul>
<li>routing_key 代表队列的名字</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">credentials = pika.PlainCredentials(<span class="string">'aaa'</span>, <span class="string">'123'</span>)  <span class="comment"># 配置认证的用户 密码</span></div><div class="line">parameters = pika.ConnectionParameters(host=<span class="string">"192.168.11.144"</span>, credentials=credentials)</div><div class="line">connection = pika.BlockingConnection(parameters)  <span class="comment"># 建立一个链接对象</span></div><div class="line">channel = connection.channel()  <span class="comment"># 队列连接通道</span></div><div class="line"></div><div class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)  <span class="comment"># 声明queue 用rabbitmqctl list_queuse 查看</span></div><div class="line">channel.basic_publish(exchange=<span class="string">''</span>, routing_key=<span class="string">'hello'</span>, body=<span class="string">'server hello world'</span>)  <span class="comment"># routing_key 代表要发送的队列 body是发送的内容</span></div><div class="line">print(<span class="string">'server send "hello world"'</span>)</div><div class="line">connection.close()  <span class="comment"># 关闭连接 类似socket</span></div></pre></td></tr></table></figure>
<p>消费者：</p>
<ul>
<li>消费者是一种阻塞模式，会一致取数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">credentials = pika.PlainCredentials(<span class="string">'aaa'</span>, <span class="string">'123'</span>)  <span class="comment"># 配置认证的用户 密码</span></div><div class="line">parameters = pika.ConnectionParameters(host=<span class="string">"192.168.11.144"</span>, credentials=credentials)</div><div class="line">connection = pika.BlockingConnection(parameters)  <span class="comment"># 建立一个链接对象</span></div><div class="line">channel = connection.channel()  <span class="comment"># 队列连接通道</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">"Recived %r"</span> % ch, method, properties, body)</div><div class="line"></div><div class="line">channel.basic_consume(callback,  <span class="comment"># 取到消息后，执行callback函数</span></div><div class="line">                      queue=<span class="string">'hello'</span>, <span class="comment"># 从hello队列获取数据</span></div><div class="line">                      no_ack=<span class="keyword">True</span></div><div class="line">                      )</div><div class="line">print(<span class="string">"waiting for message"</span>)</div><div class="line">channel.start_consuming()  <span class="comment"># 进入阻塞模式</span></div></pre></td></tr></table></figure>
<p><img src="http://images2017.cnblogs.com/blog/658994/201708/658994-20170808184951199-2113197381.png" alt=""></p>
<h3 id="3-如何保证队列中的消息被处理完毕"><a href="#3-如何保证队列中的消息被处理完毕" class="headerlink" title="3 如何保证队列中的消息被处理完毕"></a>3 如何保证队列中的消息被处理完毕</h3><p>没有处理完，应该返回队列,上面的代码中，如果消费者客户端挂了，或者在处理的过程中停止了，没有处理完毕，同时队列中也没有了。</p>
<h4 id="3-1-消费者端："><a href="#3-1-消费者端：" class="headerlink" title="3.1 消费者端："></a>3.1 消费者端：</h4><pre><code>- no_ack = True 消息处理后，不向rabbit-server确认消息已消费完毕
删除这个参数，rabbit-server的消息队列中会一致存在数据   

解决rabbit-server中消息被消费后数据还存在的情况，用basic_ack(delivery_tag=method.delivery_tag)
</code></pre><p>通过这两个参数，同时保证了消费者能够消费完数据不挂，同时消费完后rabbit-server收到消费完的消息把被消费的数据删除</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">credentials = pika.PlainCredentials(<span class="string">'aaa'</span>, <span class="string">'123'</span>)  <span class="comment"># 配置认证的用户 密码</span></div><div class="line">parameters = pika.ConnectionParameters(host=<span class="string">"192.168.11.144"</span>, credentials=credentials)</div><div class="line">connection = pika.BlockingConnection(parameters)  <span class="comment"># 建立一个链接对象</span></div><div class="line">channel = connection.channel()  <span class="comment"># 队列连接通道</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    time.sleep(<span class="number">10</span>)</div><div class="line">    print(<span class="string">"Recived %r"</span> % ch, method, properties, body)</div><div class="line">    ch.basic_ack(delivery_tag=method.delivery_tag) <span class="comment"># 这个是表示消费者处理完了</span></div><div class="line"></div><div class="line"></div><div class="line">channel.basic_consume(callback,  <span class="comment"># 取到消息后，执行callback函数</span></div><div class="line">                      queue=<span class="string">'hello'</span>,</div><div class="line">                      <span class="comment"># no_ack=True</span></div><div class="line">                      )</div><div class="line">print(<span class="string">"waiting for message"</span>)</div><div class="line">channel.start_consuming()  <span class="comment"># 进入阻塞模式</span></div></pre></td></tr></table></figure>
<h4 id="3-2-rabbitmq-server-保持持久-durable-True"><a href="#3-2-rabbitmq-server-保持持久-durable-True" class="headerlink" title="3.2 rabbitmq-server 保持持久 durable=True"></a>3.2 rabbitmq-server 保持持久 durable=True</h4><p>rabbitmq-server重启后，所有的消息就都丢失了</p>
<p>保持队列持久化 durable = True，在队列开始的时候声明，不能对已经生成的队列进行设置，重新对一个队列进行设置。</p>
<ul>
<li>通过参数delivery_mode = 2 把消息变成持久化的</li>
<li>即便是rabbitmq服务重启后，也不会丢消息</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">credentials = pika.PlainCredentials(<span class="string">'aaa'</span>, <span class="string">'123'</span>)  <span class="comment"># 配置认证的用户 密码</span></div><div class="line">parameters = pika.ConnectionParameters(host=<span class="string">"192.168.11.144"</span>, credentials=credentials)</div><div class="line">connection = pika.BlockingConnection(parameters)  <span class="comment"># 建立一个链接对象</span></div><div class="line">channel = connection.channel()  <span class="comment"># 队列连接通道</span></div><div class="line"></div><div class="line">channel.queue_declare(queue=<span class="string">'hello222'</span>,durable=<span class="keyword">True</span>)  <span class="comment"># 声明queue 用rabbitmqctl list_queuse 查看</span></div><div class="line">channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                      routing_key=<span class="string">'hello222'</span>,</div><div class="line">                      body=<span class="string">'server hello world'</span>,</div><div class="line">                      properties=pika.BasicProperties(</div><div class="line">                          delivery_mode=<span class="number">2</span>,  <span class="comment"># make message persistent</span></div><div class="line">                      )</div><div class="line">                      )  <span class="comment"># routing_key 代表要发送的队列 body是发送的内容</span></div><div class="line">print(<span class="string">'server send "hello world"'</span>)</div><div class="line">connection.close()  <span class="comment"># 关闭连接 类似socket</span></div></pre></td></tr></table></figure>
<h3 id="4-多个消费者的时候-消费者的公平分发"><a href="#4-多个消费者的时候-消费者的公平分发" class="headerlink" title="4 多个消费者的时候(消费者的公平分发)"></a>4 多个消费者的时候(消费者的公平分发)</h3><p><img src="http://www.rabbitmq.com/img/tutorials/python-two.png?_=5248247" alt=""></p>
<p>轮询获取队列中的数据，如果有一个消费者处理慢了，其他的消费者需要一直等着</p>
<p>解决方案，消费者先处理完，先获得数据</p>
<p>在消费者开始消费之前，加上<code>perfetch_count=1</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">credentials = pika.PlainCredentials(<span class="string">'aaa'</span>, <span class="string">'123'</span>)  <span class="comment"># 配置认证的用户 密码</span></div><div class="line">parameters = pika.ConnectionParameters(host=<span class="string">"192.168.11.144"</span>, credentials=credentials)</div><div class="line">connection = pika.BlockingConnection(parameters)  <span class="comment"># 建立一个链接对象</span></div><div class="line">channel = connection.channel()  <span class="comment"># 队列连接通道</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    time.sleep(<span class="number">10</span>)</div><div class="line">    print(<span class="string">"Recived %r"</span> % ch, method, properties, body)</div><div class="line">    ch.basic_ack(delivery_tag=method.delivery_tag) <span class="comment"># 这个是表示消费者处理完了</span></div><div class="line"></div><div class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>) <span class="comment"># 公平分发</span></div><div class="line">channel.basic_consume(callback,  <span class="comment"># 取到消息后，执行callback函数</span></div><div class="line">                      queue=<span class="string">'hello222'</span>,</div><div class="line">                      <span class="comment"># no_ack=True</span></div><div class="line">                      )</div><div class="line">print(<span class="string">"waiting for message"</span>)</div><div class="line">channel.start_consuming()  <span class="comment"># 进入阻塞模式</span></div></pre></td></tr></table></figure>
<h3 id="5-消息发布订阅Publish-Subscribe-消息发布-订阅-rabbit广播-组播-消息过滤-exchange"><a href="#5-消息发布订阅Publish-Subscribe-消息发布-订阅-rabbit广播-组播-消息过滤-exchange" class="headerlink" title="5 消息发布订阅Publish\Subscribe(消息发布\订阅)　 rabbit广播 组播 消息过滤(exchange)"></a>5 消息发布订阅Publish\Subscribe(消息发布\订阅)　 rabbit广播 组播 消息过滤(exchange)</h3><p>之前的消息发送都是一对一的发送和接收，如果想所有的都能接收到，类似广播的效果，用到了exchange</p>
<p><strong>订阅必须绑定并在线</strong><br>exchange在定义的时候是有类型的，以决定哪些queue符合条件，可以接收消息。<br>exchange 的消息类型:<br>    fanout: 所有bind到此exchange的queue都可以接收消息<br>    direct: 通过routingKey和exchange决定的那个唯一的queue可以接收消息<br>    topic:所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息</p>
<ul>
<li>fanout 广播 所有的队列都绑定到exchange,需要声明一个名字 不需要routing_key</li>
</ul>
<h4 id="生产者和消费者端都要声明"><a href="#生产者和消费者端都要声明" class="headerlink" title="生产者和消费者端都要声明"></a>生产者和消费者端都要声明</h4><p>生产者启动的时候，生产者没有启动的情况</p>
<h4 id="自动生成队列-消费后删除"><a href="#自动生成队列-消费后删除" class="headerlink" title="自动生成队列 消费后删除"></a>自动生成队列 消费后删除</h4><p>exclusive=True唯一的</p>
<p>rabbit 随机生成一个名字</p>
<p>广播：新浪微博 只有当前登录的才收到</p>
<p><img src="http://images2017.cnblogs.com/blog/658994/201708/658994-20170808232825808-1635320985.jpg" alt=""></p>
<p><strong>广播发送端</strong></p>
<p>运行的时候加参数 <code>Python3 producer.py info</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"></div><div class="line">credentials = pika.PlainCredentials(<span class="string">'aaa'</span>, <span class="string">'123'</span>)</div><div class="line">parameters = pika.ConnectionParameters(host=<span class="string">'192.168.43.20'</span>, credentials=credentials)</div><div class="line">connection = pika.BlockingConnection(parameters)</div><div class="line"></div><div class="line">channel = connection.channel() <span class="comment"># 队列连接通道</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'logs'</span>,type=<span class="string">'fanout'</span>) <span class="comment"># exchange='log' 所有的队列 绑定到log 设置为广播模式</span></div><div class="line"></div><div class="line">message = <span class="string">' '</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">"info：Hello World"</span></div><div class="line">channel.basic_publish(</div><div class="line">    exchange = <span class="string">'logs'</span>, <span class="comment"># 绑定到logs</span></div><div class="line">    routing_key=<span class="string">''</span>,<span class="comment"># 路由不用设置</span></div><div class="line">    body = message</div><div class="line">)</div><div class="line">print(<span class="string">"send %r"</span>%message)</div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<p><strong>广播接收端</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">credentials = pika.PlainCredentials(<span class="string">'aaa'</span>, <span class="string">'123'</span>)</div><div class="line">parameters = pika.ConnectionParameters(host=<span class="string">'192.168.43.20'</span>, credentials=credentials)</div><div class="line">connection = pika.BlockingConnection(parameters)</div><div class="line"></div><div class="line"></div><div class="line">channel = connection.channel()  <span class="comment"># 队列连接通道</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'logs'</span>, type=<span class="string">'fanout'</span>)  <span class="comment"># exchange='log' 所有的队列 绑定到log 设置为广播模式</span></div><div class="line"></div><div class="line"><span class="comment"># 不指定queue名字,rabbit会随机分配一个名字,exclusive=True会在使用此queue的消费者断开后,自动将queue删除</span></div><div class="line">queue_obj = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">queue_name = queue_obj.method.queue</div><div class="line">print(<span class="string">'queuename'</span>,queue_name,queue_obj)</div><div class="line"><span class="comment"># 绑定到队列</span></div><div class="line">channel.queue_bind(exchange=<span class="string">'logs'</span>,queue=queue_name)</div><div class="line">print(<span class="string">"witing for logs"</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch,method,properties,body)</span>:</span></div><div class="line">    print(<span class="string">"%s"</span>%body)</div><div class="line">channel.basic_consume(callback,queue=queue_name,no_ack=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure></p>
<ul>
<li>direct 组播</li>
</ul>
<p>发什么类型的，什么类型的接收,在接收端运行的时候加参数，指定接收的类型</p>
<p><img src="http://images2017.cnblogs.com/blog/658994/201708/658994-20170809002827902-992989750.jpg" alt=""></p>
<p><strong>发送端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"></div><div class="line">credentials = pika.PlainCredentials(<span class="string">'aaa'</span>, <span class="string">'123'</span>)</div><div class="line">parameters = pika.ConnectionParameters(host=<span class="string">'192.168.43.20'</span>, credentials=credentials)</div><div class="line">connection = pika.BlockingConnection(parameters)</div><div class="line"></div><div class="line"><span class="comment"># channel = connection.channel() # 队列连接通道</span></div><div class="line"><span class="comment"># channel.exchange_declare(exchange='direct_log',type='direct') # exchange='log' 所有的队列 绑定到log 设置为广播模式</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># log_level = sys.argv[1] if len(sys.argv) &gt; 1 else 'info'  # 默认是info</span></div><div class="line"><span class="comment"># message = ' '.join(sys.argv[1:]) or "info：Hello World"</span></div><div class="line"><span class="comment"># channel.basic_publish(</span></div><div class="line"><span class="comment">#     exchange = 'direct_log', # 绑定到logs</span></div><div class="line"><span class="comment">#     routing_key='log_level',</span></div><div class="line"><span class="comment">#     body = message</span></div><div class="line"><span class="comment"># )</span></div><div class="line"><span class="comment"># print("send %r"%message)</span></div><div class="line"><span class="comment"># connection.close()</span></div><div class="line"></div><div class="line"></div><div class="line">channel = connection.channel() <span class="comment">#队列连接通道</span></div><div class="line"></div><div class="line">channel.exchange_declare(exchange=<span class="string">'direct_log'</span>,type=<span class="string">'direct'</span>)</div><div class="line"></div><div class="line">log_level =  sys.argv[<span class="number">1</span>] <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="string">'info'</span></div><div class="line"></div><div class="line">message = <span class="string">' '</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">"info: Hello World!"</span></div><div class="line"></div><div class="line">channel.basic_publish(exchange=<span class="string">'direct_log'</span>,</div><div class="line">                      routing_key=log_level,</div><div class="line">                      body=message)</div><div class="line">print(<span class="string">" [x] Sent %r"</span> % message)</div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<p><strong>接收端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">credentials = pika.PlainCredentials(<span class="string">'aaa'</span>, <span class="string">'123'</span>)</div><div class="line">parameters = pika.ConnectionParameters(host=<span class="string">'192.168.43.20'</span>, credentials=credentials)</div><div class="line">connection = pika.BlockingConnection(parameters)</div><div class="line"></div><div class="line">channel = connection.channel()  <span class="comment"># 队列连接通道</span></div><div class="line">queue_obj = channel.queue_declare(</div><div class="line">    exclusive=<span class="keyword">True</span>)  <span class="comment"># 不指定queue名字,rabbit会随机分配一个名字,exclusive=True会在使用此queue的消费者断开后,自动将queue删除</span></div><div class="line">queue_name = queue_obj.method.queue</div><div class="line">print(<span class="string">'queue name'</span>, queue_name, queue_obj)</div><div class="line"></div><div class="line">log_levels = sys.argv[<span class="number">1</span>:]  <span class="comment"># 参数是 info warning error</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> log_levels:</div><div class="line">    sys.stderr.write(<span class="string">"usage %s"</span> % sys.argv[<span class="number">0</span>])</div><div class="line">    sys.exit(<span class="number">1</span>)</div><div class="line"><span class="keyword">for</span> level <span class="keyword">in</span> log_levels:</div><div class="line">    channel.queue_bind(</div><div class="line">        exchange=<span class="string">'direct_log'</span>,</div><div class="line">        queue=queue_name,</div><div class="line">        routing_key=level</div><div class="line">    )</div><div class="line">print(<span class="string">' [*] Waiting for logs. To exit press CTRL+C'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] %r"</span> % body)</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="keyword">True</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<ul>
<li>按照规则过滤播 topic 更细致</li>
</ul>
<p>可以根据正则进行更精确的匹配</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">python topic_sonsumer.py *.info   <span class="comment"># 接收以info结尾的数据</span></div><div class="line">python topic_sonsumer.py *.error mysql.* <span class="comment"># 接收以error结尾或者mysql开头的数据</span></div><div class="line">python topic_sonsumer.py <span class="string">'#'</span>  <span class="comment"># 接收所有消息</span></div><div class="line"></div><div class="line"><span class="comment"># 接收所有的 logs run:</span></div><div class="line"><span class="comment"># python receive_logs_topic.py "#"</span></div><div class="line"></div><div class="line"><span class="comment"># To receive all logs from the facility "kern":</span></div><div class="line"><span class="comment"># python receive_logs_topic.py "kern.*"</span></div><div class="line"></div><div class="line"><span class="comment"># Or if you want to hear only about "critical" logs:</span></div><div class="line"><span class="comment"># python receive_logs_topic.py "*.critical"</span></div><div class="line"></div><div class="line"><span class="comment"># You can create multiple bindings:</span></div><div class="line"><span class="comment"># python receive_logs_topic.py "kern.*" "*.critical"</span></div><div class="line"></div><div class="line"><span class="comment"># And to emit a log with a routing key "kern.critical" type:</span></div><div class="line"><span class="comment"># python emit_log_topic.py "kern.critical" "A critical kernel error"</span></div></pre></td></tr></table></figure>
<p><img src="http://images2017.cnblogs.com/blog/658994/201708/658994-20170809201519136-1750807597.jpg" alt=""></p>
<p><img src="http://images2017.cnblogs.com/blog/658994/201708/658994-20170809202558761-1869604347.jpg" alt=""></p>
<p><strong>发送端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"></div><div class="line">credentials = pika.PlainCredentials(<span class="string">'aaa'</span>, <span class="string">'123'</span>)</div><div class="line">parameters = pika.ConnectionParameters(host=<span class="string">'192.168.11.144'</span>, credentials=credentials)</div><div class="line">connection = pika.BlockingConnection(parameters)</div><div class="line"></div><div class="line">channel = connection.channel() <span class="comment">#队列连接通道</span></div><div class="line"></div><div class="line">channel.exchange_declare(exchange=<span class="string">'topic_log'</span>,type=<span class="string">'topic'</span>) <span class="comment"># 设置成topic模式</span></div><div class="line"></div><div class="line">log_level =  sys.argv[<span class="number">1</span>] <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="string">'info'</span></div><div class="line"></div><div class="line">message = <span class="string">' '</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">"info: Hello World!"</span></div><div class="line"></div><div class="line">channel.basic_publish(exchange=<span class="string">'topic_log'</span>,</div><div class="line">                      routing_key=log_level,</div><div class="line">                      body=message)</div><div class="line">print(<span class="string">" [x] Sent %r"</span> % message)</div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<p><strong>接收端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">credentials = pika.PlainCredentials(<span class="string">'aaa'</span>, <span class="string">'123'</span>)</div><div class="line">parameters = pika.ConnectionParameters(host=<span class="string">'192.168.11.144'</span>, credentials=credentials)</div><div class="line">connection = pika.BlockingConnection(parameters)</div><div class="line"></div><div class="line">channel = connection.channel()  <span class="comment"># 队列连接通道</span></div><div class="line">queue_obj = channel.queue_declare(</div><div class="line">    exclusive=<span class="keyword">True</span>)  <span class="comment"># 不指定queue名字,rabbit会随机分配一个名字,exclusive=True会在使用此queue的消费者断开后,自动将queue删除</span></div><div class="line">queue_name = queue_obj.method.queue</div><div class="line">print(<span class="string">'queue name'</span>, queue_name, queue_obj)</div><div class="line"></div><div class="line">log_levels = sys.argv[<span class="number">1</span>:]  <span class="comment"># 参数是 info warning error</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> log_levels:</div><div class="line">    sys.stderr.write(<span class="string">"usage %s"</span> % sys.argv[<span class="number">0</span>])</div><div class="line">    sys.exit(<span class="number">1</span>)</div><div class="line"><span class="keyword">for</span> level <span class="keyword">in</span> log_levels:</div><div class="line">    channel.queue_bind(</div><div class="line">        exchange=<span class="string">'topic_log'</span>,  <span class="comment"># 从topic_log 队列中获取</span></div><div class="line">        queue=queue_name,</div><div class="line">        routing_key=level</div><div class="line">    )</div><div class="line">print(<span class="string">' [*] Waiting for logs. To exit press CTRL+C'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] %r"</span> % body)</div><div class="line"></div><div class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="keyword">True</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<h2 id="RPC-remote-producer-call"><a href="#RPC-remote-producer-call" class="headerlink" title="RPC remote producer call"></a>RPC remote producer call</h2><p>不知道你有没有发现，上面的流都是单向的，如果远程的机器执行完返回结果，就实现不了了。<br>如果返回，这种模式叫什么呢，RPC（远程过程调用），snmp就是典型的RPC<br>RabbitMQ能不能返回呢，怎么返回呢？既是发送端又是接收端。<br>但是接收端返回消息怎么返回？可以发送到发过来的queue里么？不可以。<br>返回时，再建立一个queue，把结果发送新的queue里<br>为了服务端返回的queue不写死，在客户端给服务端发指令的的时候，同时带一条消息说，你结果返回给哪个queue</p>
<p><img src="http://www.rabbitmq.com/img/tutorials/python-six.png?_=5248247" alt=""></p>
<p><strong>task1，task2异步执行，但是返回的顺序是不固定的，为了区分是谁执行完的，在发送的任务添加唯一标识符，这样取回的时候就能区分</strong></p>
<h3 id="设置一个异步RPC"><a href="#设置一个异步RPC" class="headerlink" title="设置一个异步RPC"></a>设置一个异步RPC</h3><ul>
<li>声明一个队列reply_to，作为返回消息结果的队列</li>
<li>发送消息队列，消息中带唯一标识uid</li>
<li>监听reply_to队列，直到有结果</li>
</ul>
<p>在类中声明监听</p>
<p><strong>发送端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> subprocess</div><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="comment"># 1 。 定义fib函数</span></div><div class="line"><span class="comment"># 2. 声明接收指令的队列名rpc_queue</span></div><div class="line"><span class="comment"># 3. 开始监听队列，收到消息后 调用fib函数</span></div><div class="line"><span class="comment"># 4 把fib执行结果，发送回客户端指定的reply_to 队列</span></div><div class="line"></div><div class="line">credentials = pika.PlainCredentials(<span class="string">'aaa'</span>, <span class="string">'123'</span>)</div><div class="line">parameters = pika.ConnectionParameters(host=<span class="string">'192.168.11.144'</span>, credentials=credentials)</div><div class="line">connection = pika.BlockingConnection(parameters)</div><div class="line"></div><div class="line">channel = connection.channel()  <span class="comment"># 队列连接通道</span></div><div class="line"></div><div class="line">channel.queue_declare(queue=<span class="string">'rpc_queue2'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_cmd</span><span class="params">(cmd)</span>:</span></div><div class="line">    cmd_obj = subprocess.Popen(cmd, shell=<span class="keyword">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</div><div class="line">    result = cmd_obj.stdout.read() + cmd_obj.stderr.read()</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_request</span><span class="params">(ch, method, props, body)</span>:</span></div><div class="line">    cmd = body.decode(<span class="string">"utf-8"</span>)</div><div class="line"></div><div class="line">    print(<span class="string">" [.] run (%s)"</span> % cmd)</div><div class="line">    response = run_cmd(cmd)</div><div class="line"></div><div class="line">    ch.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                     routing_key=props.reply_to,  <span class="comment"># 队列</span></div><div class="line">                     properties=pika.BasicProperties(correlation_id= \</div><div class="line">                                                         props.correlation_id),</div><div class="line">                     body=response)</div><div class="line"></div><div class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_consume(on_request, queue=<span class="string">'rpc_queue2'</span>)</div><div class="line"></div><div class="line">print(<span class="string">" [x] Awaiting RPC requests"</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<p><strong>接收端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> queue</div><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> uuid</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 1.声明一个队列，作为reply_to返回消息结果的队列</span></div><div class="line"><span class="comment"># 2.  发消息到队列，消息里带一个唯一标识符uid，reply_to</span></div><div class="line"><span class="comment"># 3.  监听reply_to 的队列，直到有结果</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMDRpcClient</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        credentials = pika.PlainCredentials(<span class="string">'aaa'</span>, <span class="string">'123'</span>)</div><div class="line">        parameters = pika.ConnectionParameters(host=<span class="string">'192.168.11.144'</span>, credentials=credentials)</div><div class="line">        self.connection = pika.BlockingConnection(parameters)</div><div class="line">        self.channel = self.connection.channel()</div><div class="line"></div><div class="line">        result = self.channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">        self.callback_queue = result.method.queue  <span class="comment"># 命令的执行结果的queue</span></div><div class="line"></div><div class="line">        <span class="comment"># 声明要监听callback_queue</span></div><div class="line">        self.channel.basic_consume(self.on_response, no_ack=<span class="keyword">True</span>,</div><div class="line">                                   queue=self.callback_queue)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_response</span><span class="params">(self, ch, method, props, body)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        收到服务器端命令结果后执行这个函数</div><div class="line">        :param ch:</div><div class="line">        :param method:</div><div class="line">        :param props:</div><div class="line">        :param body:</div><div class="line">        :return:</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> self.corr_id == props.correlation_id:</div><div class="line">            self.response = body.decode(<span class="string">"gbk"</span>)  <span class="comment"># 把执行结果赋值给Response</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, n)</span>:</span></div><div class="line">        self.response = <span class="keyword">None</span></div><div class="line">        self.corr_id = str(uuid.uuid4())  <span class="comment"># 唯一标识符号</span></div><div class="line">        self.channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                                   routing_key=<span class="string">'rpc_queue2'</span>,</div><div class="line">                                   properties=pika.BasicProperties(</div><div class="line">                                       reply_to=self.callback_queue,</div><div class="line">                                       correlation_id=self.corr_id,</div><div class="line">                                   ),</div><div class="line">                                   body=str(n))</div><div class="line"></div><div class="line">        <span class="keyword">while</span> self.response <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            self.connection.process_data_events()  <span class="comment"># 检测监听的队列里有没有新消息，如果有，收，如果没有，返回None</span></div><div class="line">            <span class="comment"># 检测有没有要发送的新指令</span></div><div class="line">        <span class="keyword">return</span> self.response</div><div class="line"></div><div class="line"></div><div class="line">cmd_rpc = CMDRpcClient()</div><div class="line"></div><div class="line">print(<span class="string">" [x] Requesting fib(30)"</span>)</div><div class="line">response = cmd_rpc.call(<span class="string">'ipconfig'</span>)</div><div class="line"></div><div class="line">print(response)</div></pre></td></tr></table></figure>
<p>参考：<br><a href="http://blog.csdn.net/fgf00/article/details/52872730" target="_blank" rel="external">http://blog.csdn.net/fgf00/article/details/52872730</a><br><a href="http://www.cnblogs.com/alex3714/articles/5248247.html" target="_blank" rel="external">http://www.cnblogs.com/alex3714/articles/5248247.html</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Django/">Django</a></li></ul>

      
        
	<div id="comment">
	
	<!-- 多说评论框 start -->
	 <div class="ds-thread" data-thread-key="/2017/08/08/rabbitmq消息队列/" data-title="rabbitmq消息队列" data-url="https://github.com/ythzx/ythzx.github.io/2017/08/08/rabbitmq消息队列/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"ythzx"};
	  (function() {
	    var ds = document.createElement('script');
	    ds.type = 'text/javascript';ds.async = true;
	    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	    ds.charset = 'UTF-8';
	    (document.getElementsByTagName('head')[0] 
	     || document.getElementsByTagName('body')[0]).appendChild(ds);
	  })();
	  </script>
	<!-- 多说公共JS代码 end -->
	
	</div>
	<link rel="stylesheet" href="/css/comment.css">


      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/08/24/算法/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          算法
        
      </div>
    </a>
  
  
    <a href="/2017/08/07/GIT系列/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Git 分布式版本控制系统</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#rabbitmq消息队列"><span class="nav-number">1.</span> <span class="nav-text">rabbitmq消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#centos下yum安装RabbitMQ"><span class="nav-number">1.1.</span> <span class="nav-text">centos下yum安装RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#python的队列-queue"><span class="nav-number">1.1.1.</span> <span class="nav-text">python的队列 queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息队列解决的问题："><span class="nav-number">1.1.2.</span> <span class="nav-text">消息队列解决的问题：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列的作用："><span class="nav-number">1.1.3.</span> <span class="nav-text">队列的作用：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引入rabbitmq的原因："><span class="nav-number">1.1.4.</span> <span class="nav-text">引入rabbitmq的原因：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者消费者模型"><span class="nav-number">1.1.5.</span> <span class="nav-text">生产者消费者模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ-配置"><span class="nav-number">1.2.</span> <span class="nav-text">RabbitMQ 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rabbitmq-创建用户和设置权限"><span class="nav-number">1.2.1.</span> <span class="nav-text">rabbitmq 创建用户和设置权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端连接的时候需要配置认证参数"><span class="nav-number">1.2.2.</span> <span class="nav-text">客户端连接的时候需要配置认证参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ-都能为程序提供队列"><span class="nav-number">1.3.</span> <span class="nav-text">RabbitMQ 都能为程序提供队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-rabbitmq的路由routing-key"><span class="nav-number">1.3.1.</span> <span class="nav-text">1 rabbitmq的路由routing_key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-实现最简单的队列"><span class="nav-number">1.3.2.</span> <span class="nav-text">2 实现最简单的队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-如何保证队列中的消息被处理完毕"><span class="nav-number">1.3.3.</span> <span class="nav-text">3 如何保证队列中的消息被处理完毕</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-消费者端："><span class="nav-number">1.3.3.1.</span> <span class="nav-text">3.1 消费者端：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-rabbitmq-server-保持持久-durable-True"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">3.2 rabbitmq-server 保持持久 durable=True</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-多个消费者的时候-消费者的公平分发"><span class="nav-number">1.3.4.</span> <span class="nav-text">4 多个消费者的时候(消费者的公平分发)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-消息发布订阅Publish-Subscribe-消息发布-订阅-rabbit广播-组播-消息过滤-exchange"><span class="nav-number">1.3.5.</span> <span class="nav-text">5 消息发布订阅Publish\Subscribe(消息发布\订阅)　 rabbit广播 组播 消息过滤(exchange)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生产者和消费者端都要声明"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">生产者和消费者端都要声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动生成队列-消费后删除"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">自动生成队列 消费后删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RPC-remote-producer-call"><span class="nav-number">1.4.</span> <span class="nav-text">RPC remote producer call</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设置一个异步RPC"><span class="nav-number">1.4.1.</span> <span class="nav-text">设置一个异步RPC</span></a></li></ol></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2017 Peter&#39;s Blog Center All Rights Reserved.
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var contentdiv = document.getElementById("content");

    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>






<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?93b40df12317201527431272f20ac28a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
  

  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>


  <script type="text/javascript" color="33,33,33" zindex="-1" opacity="1" count="80" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
